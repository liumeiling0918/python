1. ORM已经的学过的内容：
		1. Django项目如何使用ORM连接MySQL
			1. 手动创建数据库
			2. 在settings.py里面配置一下数据库的连接信息（告诉Django连接哪一个数据库）
				DATABASES = {
					'default': {
						'ENGINE': 'django.db.backends.mysql',  # 连接数据库的类型
						'NAME': 'day62xiawu',  # 数据库名字
						'HOST': '127.0.0.1',  # IP
						'PORT': 3306,  # 端口
						'USER': 'root',  # 用户名
						'PASSWORD': '123456',  # 密码
					}
				}
			3. 在和settings.py同目录下的__init__.py文件中，告诉Django用pymysql代替MySQLdb来连接数据库
				import pymysql
				pymysql.install_as_MySQLdb()
			4. 在app/models.py中，定义类，类一定要继承models.Model
				class Book(models.Model):
					id = models.AutoField(primary_key=True)
					title = models.CharField(max_length=32)
			5. 执行两条命令
				1. 在哪儿执行？
					在项目的根目录（有manage.py文件的那个目录）
				2. 命令
					python manage.py makemigrations   --> 将models.py文件中的改动记录在小本本（app/migrations/00xx_****.py）上
					
					python manage.py migrate           --> 将改动翻译成SQL语句，去数据库中执行
		2. 表和表之间的关系
			1. 一对多（书和出版社）
				class Publisher(models.Model):
					id=models.AutoField(primary_key=True)
					name=models.CharField(max_length=22,unique=True)

				class Book(models.Model):
					id=models.AutoField(primary_key=True)
					title=models.CharField(max_length=32)
					# 一对一的关联，一本书对应一个出版社
					publisher=models.ForeignKey(to="Publisher")

				在数据库中：
					有没有publisher这个字段？
					数据库中实际 生成的是一个 publisher_id 字段
				
			2. 多对多（作者和书）
				class Author(models.Model):
					id=models.AutoField(primary_key=True)
					name=models.CharField(max_length=32)
					# 一对多的关联，一个作者对应多本书
					books=models.ManyToManyField(to="Book")
				
				在数据库中：
					是通过第三张表建立的关系

		3. 增删改查操作
			1. 单表增删改查
				增：
					models.Publisher.objects.create(name="沙河出版社")
				查：
					models.Publisher.objects.get(id=1)
					models.Publisher.objects.get(name="沙河出版社")
				删：
					models.Publisher.objects.get(id=1).delete()
				改：
					obj = models.Publisher.objects.get(id=1)
					obj.name = "沙河第二出版社"
					obj.save()
			2. 外键的增删改查
				增、删、查同上
				一本书对应一个出版社
				book_obj = models.Book.objects.get(id=1)
				
				book_obj.publisher 是什么？    *****
					和我这本书关联的出版社对象
					
					book_obj.publisher.id    和我这本书关联的出版社的id值
					book_obj.publisher.name  和我这本书关联的出版社的名称
					
				book_obj.publisher_id 是什么？
					和我这本书关联的出版社的id值
					
			3. 多对多操作
				
				1. 查id为1的作者都写过的书？一个作者对应多本书
					author_obj = models.Author.objects.get(id=1)
					author_obj.books.all()     --> 和我这个作者关联的所有书对象
				2. 想给作者绑定多本书？ 一个作者对应多本书
					author_obj = models.Author.objects.get(id=1)
					author_obj.books.set([1,2,3]) --> 把id是1、2、3的书和我这个作者关联上
				
2. 今日内容

		1. Django ORM常用字段：
			1. AutoField       --> int自增  (当model中如果没有自增列，则自动会创建一个列名为id的列)
			2. CharField       --> varchar(xx)
			3. ForeignKey      --> 外键 (models.ForeignKey(to=’表名‘ 或者 to_field='表格的主键'))
			4. ManyToManyField --> 多对多关联
			
			5. DateField
			6. DateTimeField
			
			7. IntegerField
			
			
		2. 自定义char字段
			class FixedCharField(models.Field):
				"""
				自定义的char类型的字段类
				"""
				def __init__(self, max_length, *args, **kwargs):
					self.max_length = max_length
					super(FixedCharField, self).__init__(max_length=max_length, *args, **kwargs)

				def db_type(self, connection):
					"""
					限定生成数据库表的字段类型为char，长度为max_length指定的值
					"""
					return 'char(%s)' % self.max_length
					
			class Person(models.Model):
				name = models.CharField(max_length=32)
				new_name = FixedCharField(max_length=64, default="张三")  # char(64)
				age = models.IntegerField(default=18)
				birthday = models.DateField(auto_now_add=True)
						
			
		3. 常用的字段参数
			1. null
			2. default
			3. unique
			4. db_index 建立索引
			
			5. DateField和DateTimeField才有的参数：
				auto_now_add=True     --> 创建数据的时候自动把当前时间赋值
				auto_add=True         --> 每次更新数据的时候更新当前时间
				
				上述两个不能同时设置！！！
			
			5. class Meta:
				 db_table = "表名"
				 
			class Book(models.Model):
				id = models.AutoField(primary_key=True)
				title = models.CharField(max_length=32)
				# 外键
				publisher = models.ForeignKey(to="Publisher", on_delete=models.CASCADE, db_constraint=False)
			   #on_delete=models.CASCADE  级联操作（Book表中含有publisher字段） publisher删除时，所关联的book表也会删除
				# db_constraint=False 拒绝在表格级别做外键，只能通过代码控制表格之间关系。
				# db_constraint=False 时说明该外键语句只是起到提示，不会有真正的关联操作

				def __str__(self):
					return self.title

				class Meta:
					db_table = "book"
				 # 通过Meta自定义表名
3.增删改查操作：
http://www.cnblogs.com/liwenzhou/p/8660826.html
		1.# 在python脚本中运行Django项目,操作数据库（增删改查），需要加载Django项目的配置和变量信息
		import os
		if __name__=='__main__':
		    # 加载Django项目的配置信息
		    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "myday681.settings")
		    #导入Django，并启动Django项目
		    import django
		    django.setup()
		    #操作数据库
		    from myapp01 import models
		    # 查询所有人 返回QuerySet
		    # ret=models.Person.objects.all()
		    # print(ret)
		    # print(ret[0].name)

		    # get查询  返回object对象 #不存在则会报错；返回的结果超过多个对象时，则报错
		    # ret1=models.Person.objects.get(name="小红")
		    # print(ret1)
		    # print(ret1.age)
		    # ret2=models.Person.objects.get(name="xiaohong")
		    # 返回的结果超过多个对象时，则报错
		    # ret3=models.Person.objects.get(age=13)
		    # print(ret3)

		    # filter 返回QuerySet 不存在返回一个空的QuerySet，不会报错
		    # ret3=models.Person.objects.filter(id=1)
		    # print(ret3)
		    # print(ret3[0].name)
		    # ret4=models.Person.objects.filter(id=9)
		    # print(ret4)
		    # # 返回的结果超过多个对象时，
		    # ret5=models.Person.objects.filter(age=13)
		    # print(ret5)

		    # exclude 返回QuerySet 返回与所给筛选条件不匹配的对象
		    # ret6=models.Person.objects.exclude(id=1)
		    # print(ret6)

		    # values 返回一个QuerySet对象，里面都是字典。若不写字段名，默认查询所有字段
		    # ret7=models.Person.objects.values("name","birthday")
		    # print(ret7)
		    # ret8=models.Person.objects.values()
		    # print(ret8)

		    # values_list 返回一个QuerySet对象，里面都是元祖。 若不写字段名，默认查询所有字段
		    # ret9=models.Person.objects.values_list("name","birthday")
		    # print(ret9)
		    # ret10=models.Person.objects.values_list()
		    # print(ret10)

		    #order_by 按照指定的字段排序,返回QuerySet,
		    # ret11=models.Person.objects.order_by("age")
		    # for i in ret11:
		    #     print(i.age)

		    # reverse 将一个有序的QuerySet 反转。
		    # 有序的QuerySet才能调用reverse (在model类的Meta中指定ordering或调用order_by()方法)
		    # 调用order_by()方法后的反转
		    # ret12=models.Person.objects.order_by("age").reverse()
		    # for i in ret12:
		    #     print(i.age)
		    # 在model类的Meta中指定ordering
		    # class Person(models.Model):
		    #     name = models.CharField(max_length=32)
		    #     age = models.IntegerField(default=18)
		    #     birthday = models.DateField(auto_now_add=True)
		    #
		    #     class Meta:
		    #         ordering = ("age",)

		    # ret13=models.Person.objects.all().reverse()
		    # for i in ret13:
		    #     print(i.age)


		    # count 返回QuerySet中对象的数量
		    # ret14=models.Person.objects.all().count()
		    # print(ret14)

		    # first 返回QuerySet中第一个对象
		    # ret15=models.Person.objects.all().first()
		    # print(ret15)
		    # # last 返回QuerySet中最后一个对象
		    # ret16=models.Person.objects.all().last()
		    # print(ret16)

		    # exists 判断表里有没有数据（即表格是否为空）
		    # ret17=models.Person.objects.exists()
		    # print(ret17)
		    
		  # 2.# 单表查询之双下划线
		    #gt lt
		    # # 查询id值大于1小于4的结果 (1,4)
		    # ret = models.Person.objects.filter(id__gt=1, id__lt=4)

		    # # in
		    # # 查询 id 在 [1, 3, 5, 7]中的结果
		    # ret = models.Person.objects.filter(id__in=[1, 3, 5, 7])
		    # print(ret)
		    # ret = models.Person.objects.exclude(id__in=[1, 3, 5, 7])
		    # print(ret)

		    # # contains 字段包含指定值的
		    # # icontains 忽略大小写包含指定值
		    # ret = models.Person.objects.filter(name__contains="小")
		    # print(ret)

		    # # range
		    # # 判断id值在 哪个区间的 SQL语句中的between and  1<= <=3
		    # ret = models.Person.objects.filter(id__range=[1,3])
		    # print(ret)

		    # # 日期和时间字段还可以有以下写法
		    # ret = models.Person.objects.filter(birthday__year=2000)
		    # print(ret)
		    # ret = models.Person.objects.filter(birthday__year=2000, birthday__month=5)
		    # print(ret)
		 #3. 外键的查询操作
		    # Book表中：
		    # class Book(models.Model):
		    #     id = models.AutoField(primary_key=True)
		    #     price = models.DecimalField(max_digits=5, decimal_places=2, default=99.99)
		    #     # max_digits小数的总长度 decimal_places小数点后面的位数
		    #     title = models.CharField(max_length=32)
		    #     # related_name="books" 反向查询时用来代替 book_set的
		    #     # related_query_name 反向查询使用双下划线时代替 表名__字段
		    #     publisher = models.ForeignKey(
		    #         to="Publisher",
		    #         on_delete=models.CASCADE,
		    #         related_name="books",
		    #         related_query_name="xxoo",
		    #         null=True
		    #     )

		    #Book表中关联了publisher
		    # 正向查询
		    # 基于对象 跨表查询
		    # book_obj = models.Book.objects.all().first()
		    # ret = book_obj.publisher.name  # 和我这本书关联的出版社对象
		    # print(ret, type(ret))

		    # 查询id是1的书的出版社的名称
		    # 利用双下划线 跨表查询
		    # values_list("表名_name")相当于传递跨表的字段名
		    # values("表名_name")
		    # ret = models.Book.objects.filter(id=1).values_list("publisher__name")
		    # 等价于 models.Book.objects.filter(id=11).values("publisher__name")
		    # 等价于models.Book.objects.get(id=1).publisher.name

		    # 反向查询
		    # 1. 基于对象查询
		    #通过下划线 ：表名_set
		    # ret = models.Publisher.objects.get(id=1).book_set.all()
		    #在Publisher中指定related_name="books" 代替book_set
		    # ret =  models.Publisher.objects.get(id=1).books.all()

		    #
		    # # 2. 基于双下划线
		    # 通过表名__title
		    # ret1 = models.Publisher.objects.filter(id=1).values_list("book__title")
		    #当book中配置related_name="books"(没有配置related_query_name="xxoo"时)时
		    # ret1 = models.Publisher.objects.filter(id=1).values_list("books__title")
		    # print(ret1)
		    # 当book中配置related_query_name="xxoo"时,
		    # ret = models.Publisher.objects.filter(id=1).values_list("xxoo__title")
		    # print(ret)


		    # 4.多对多(作者与书之间为多对多的关系)

		    # class Book(models.Model):
		    #     id = models.AutoField(primary_key=True)
		    #     price = models.DecimalField(max_digits=5, decimal_places=2, default=99.99)

		    # class Author(models.Model):
		    #     id = models.AutoField(primary_key=True)
		    #     name = models.CharField(max_length=32)
		    #     books = models.ManyToManyField(to="Book")

		    # 查询
		    # author_obj = models.Author.objects.first()
		    # print(author_obj.books.name)

		    # 1. create
		    # 通过作者创建一本书,会自动保存
		    # 做了两件事：
		    # 1. 在book表里面创建一本新书，2. 在作者和书的关系表中添加关联记录
		    # author_obj = models.Author.objects.first()
		    # author_obj.books.create(title="金老板自传", publisher_id=2)

		    # 2. add
		    # 在金老板关联的书里面，再加一本id是4的书
		    # author_obj = models.Author.objects.first()
		    # book_obj = models.Book.objects.get(id=4)
		    # author_obj.books.add(book_obj)
		    # 添加多个
		    # book_objs = models.Book.objects.filter(id__gt=5) #列表
		    # author_obj.books.add(*book_objs)  # 要把列表打散再传进去（相当于按位置传参）
		    # 直接添加id
		    # author_obj.books.add(9)


		    # remove
		    # 从金老板关联的书里面把 开飞船 删掉
		    # book_obj = models.Book.objects.get(title="跟金老板学开飞船")
		    # author_obj.books.remove(book_obj)
		    # 从金老板关联的书里面把 id是8的记录 删掉
		    # author_obj.books.remove(8)

		    # clear
		    #正向清空 (删除书籍)
		    # jing_obj = models.Author.objects.get(id=1)
		    # jing_obj.books.clear()


		    # 额外补充的，外键的反向操作
		    #反向清空 删除id=2的出版社出版的所有书籍
		    # 即令book表中publisher_id=2的书的publisher字段为null（前提是外键publisher允许为空）
		    # 找到id是1的出版社
		    # publisher_obj = models.Publisher.objects.get(id=2)
		    # publisher_obj.book_set.clear()


		    # 5.执行原生SQL
		    # 更高灵活度的方式执行原生SQL语句
		    # from django.db import connection
		    #
		    # cursor = connection.cursor()  # cursor = connections['default'].cursor()
		    # cursor.execute("SELECT * from app01_book where id = %s", [1])
		    # ret = cursor.fetchone()
		    # print(ret)

		    # 6.聚合
		    from django.db.models import Avg, Sum, Max, Min, Count
		    # ret = models.Book.objects.all().aggregate(price_avg=Avg("price"))
		    # print(ret) #返回一个字典
		    #
		    # ret = models.Book.objects.all().aggregate(price_avg=Avg("price"), price_max=Max("price"), price_min=Min("price"))
		    # print(ret)
		    # print(ret.get("price_max"), type(ret.get("price_max")))

		    # 7.分组查询
		    # class Author(models.Model):
		    #     id = models.AutoField(primary_key=True)
		    #     name = models.CharField(max_length=32)
		    #     # 一对多的关联，一个作者对应多本书
		    #     books = models.ManyToManyField(to="Book")

		    # 查询每一本书的作者个数（反向查询） 将book表与author_book表左关联（book_id），然后按照book_id分组,然后计数（计算每个组中author的个数）
		    #select count(authonr_book.author_id) as author_num from book
		    # left outer join authon_book on book_id=author_book.book_id group by book.id
		    ret = models.Book.objects.all().annotate(author_num=Count("author"))
		    print(ret) #QuerySet对象
		    # for book in ret:
		    #     print("书名：{}，作者数量：{}".format(book.title, book.author_num))

		    # 查询作者数量大于1的书
		    # ret = models.Book.objects.all().annotate(author_num=Count("author")).filter(author_num__gt=1)
		    # print(ret)

		    # 查询各个作者出的书的总价格（正向查询） 按照author分组
		    # ret = models.Author.objects.all().annotate(price_sum=Sum("books__price")).values_list("name", "price_sum")
		    # ret = models.Author.objects.all().annotate(price_sum=Sum("books__price"))
		    # print(ret)
		    # for i in ret:
		    #     print(i, i.name, i.price_sum)
		    # print(ret.values_list("id", "name", "price_sum"))

		    # 8.F和Q
		    # Django提供F()来做这样的比较。F()的实例可以在查询中引用字段，来比较同一个model实例中两个不同字段的值。
		    # ret = models.Book.objects.filter(price__gt=9.99)
		    # print(ret)

		    # 查询出 库存数大于卖出数的 所有书（两个字段做比较）
		    from django.db.models import F
		    # ret = models.Book.objects.filter(kucun__gt=F("maichu"))
		    # print(ret)
		    # 刷单 把每一本书的卖出数都乘以3
		    # obj = models.Book.objects.first()
		    # obj.maichu = 1000 * 3
		    # obj.save()
		    # 等价于
		    # 具体的对象没有update()，obj.update()不合法
		    # models.Book.objects.update(maichu=(F("maichu")+1)*3)

		    # 给每一本书的书名后面加上 第一版
		    # from django.db.models.functions import Concat
		    # from django.db.models import Value
		    #
		    # models.Book.objects.update(title=Concat(F("title"), Value("第一版")))


		    # Q查询
		    from django.db.models import Q
		    # 查询 卖出数大于1000，并且 价格小于100的所有书
		    # ret = models.Book.objects.filter(maichu__gt=1000, price__lt=100)
		    # print(ret)
		    # 查询 卖出数大于1000，或者 价格小于100的所有书
		    # ret = models.Book.objects.filter(Q(maichu__gt=1000) | Q(price__lt=100))
		    # print(ret)
		    # Q查询和字段查询同时存在时， 字段查询要放在Q查询的后面
		    # ret = models.Book.objects.filter(Q(maichu__gt=1000) | Q(price__lt=100), title__contains="金老板")
		    # print(ret)

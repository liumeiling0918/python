1.字符组：
    [] 匹配在同一个位置上可能出现的各种字符，
    例如[0-9]表示在同一个位置上0-9之间的数字，如3可以匹配成功
2.字符：
    . 匹配除换行符以外的任意字符
    \w	匹配字母或数字或下划线 word
    \s	匹配任意的空白符    space
    \d	匹配数字      digit
    w,s,d的大写字母表示否定形式
    \W	匹配非字母非数字非下划线
    \D	匹配非数字
    \S	匹配非空白符
    \n	匹配一个换行符
    \t	匹配一个制表符
    \b	匹配一个单词的结尾 例如 g\b 表示匹配以g结尾的单词，例如egg
    ^	匹配字符串的开始 例如^e表示匹配以e开头的字符，如egg; ^[a-z]表示匹配以小写字母开头的字符
    $	匹配字符串的结尾 例如[a-z]$表示匹配以小写字母结尾的字符
    a|b	匹配字符a或字符b
    [^...]	匹配除了字符组中字符的所有字符
    ^在[]里面表示否定的意思。^在[]外面表示以什么开头
    例如[^a-z]表示匹配非小写字母的字符，^[a-z]表示匹配以小写字母开头的字符
3.量词：
    *	重复零次或更多次
    +	重复一次或更多次
    ?	重复零次或一次
    {n}	重复n次
    {n,}	重复n次或更多次
    {n,m}	重复n到m次
    *,+,?等都是贪婪匹配（尽可能多的匹配），也就是尽可能匹配，后面加?号使其变成惰性匹配（尽可能少的匹配）
    *? 重复零次或更多次，但尽可能少重复
    +? 重复1次或更多次，但尽可能少重复
    ?? 重复0次或1次，但尽可能少重复
    {n,m}? 重复n到m次，但尽可能少重复
    {n,}? 重复n次以上，但尽可能少重复
4.分组（）
    ()	匹配括号内的表达式 
    ([a-z][0-9])+ 此处的加号对[a-z]和[0-9]都起作用	
    [a-z][0-9]+ 此处的加号只对[0-9]起作用	
    正则表达式匹配括号时需要进行转义 \（\）
5.转义符 \：对"\"进行转义，变成'\\'
    \n转义成\n（换行符）
    \\n转义成\n
    \\\\n转义成\\n
    python中的正则使用字符串表示，在字符串中\本来就具有特殊的意义，本来就需要转义。因此：
    正则中\n   python中"\\n"  实际表示匹配换行
    正则中\\n   python中"\\\\n"  实际表示匹配\n
    这种方式太麻烦，所以在python中使用r表示保持原型(即将字符串的内容读成正则原型)
    正则中\n在python中 r"\n"      实际表示匹配换行
    正则中\\n在python中r"\\n"   实际表示匹配\n
    例子：
    import re
    r=r'.*?<i>.*?(\d+)'
    com=re.compile(r,re.S)
    ret=re.findall(com,'3333<i>sfa9999')
    print(ret) #['9999']
 re.I(IGNORECASE)忽略大小写，括号内是完整的写法
re.M(MULTILINE)多行模式，改变^和$的行为
re.S(DOTALL)点可以匹配任意字符，包括换行符
re.L(LOCALE)做本地化识别的匹配，表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境，不推荐使用
re.U(UNICODE) 使用\w \W \s \S \d \D使用取决于unicode定义的字符属性。在python3中默认使用该flag
re.X(VERBOSE)冗长模式，该模式下pattern字符串可以是多行的，忽略空白字符，并可以添加注释

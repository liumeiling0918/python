1.unicode 英文4字节 中文4字节
2.ascII 英文1字节
3.utf-8 英文1字节 中文3字节
4.gbk  英文1字节 中文2字节
1，各个编码之间的二进制，是不能互相识别的，会产生乱码。
2，文件的储存（硬盘），传输，不能是unicode（只能是utf-8 utf-16 gbk,gb2312,asciid等）

py3:
    str 在内存中是用unicode编码。所以储存（硬盘），传输需要转码。（unicode存储空间太大）
        bytes类型编码方式：utf-8,gbk,gb2312,ascII,可以直接用来存储和传输
        str需要转换成bytes,然后进行存储，传输
        对于英文：
             str  ：表现形式：s = 'alex'
                    编码方式： 010101010  unicode
            bytes ：表现形式：s = b'alex'
                    编码方式： 000101010  utf-8 gbk。。。。

        对于中文：
             str  ：表现形式：s = '中国'
                    编码方式： 010101010  unicode
            bytes ：表现形式：s = b'x\e91\e91\e01\e21\e31\e32' 十六进制
                    编码方式： 000101010  utf-8 gbk。。。。
 str: s1='safa'
 bytes: s2=b'dsa'
转码：s3=s1.encode('utf-8')
注意：
在python中，编码解码其实是不同编码系统间的转换，默认情况下，转换目标是Unicode，即编码unicode→str，解码str→unicode，其中str指的是字节流
而str.decode是将字节流str按给定的解码方式解码，并转换成utf-8形式，u.encode是将unicode类按给定的编码方式转换成字节流str
注意调用encode方法的是unicode对象生成的是字节流，调用decode方法的是str对象（字节流）生成的是unicode对象，若str对象调用encode会默认先按系统默认编码方式decode成unicode对象再encode，忽视了中间默认的decode往往导致报错
自己写代码时只需记住str字节流调用decode，unicode对象调用
